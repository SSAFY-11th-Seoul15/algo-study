박소미 : BOJ 1194 달이 차오른다, 가자.

## 1. 문제를 읽고 이해하기
#### [문제] 
  - 성을 적에게서 지키기 위해 궁수 3명을 성이 있는 칸에 배치
  - 각각의 턴마다 궁수는 적(D이하인 적 중에서 가장 가까운 적이고, 그러한 적이 여럿일 경우에는 가장 왼쪽에 있는 적) 하나를 공격할 수 있고, 모든 궁수는 동시에 공격
  - 궁수의 공격이 끝나면, 적은 아래로 한 칸 이동
  - 공격받거나 성이 있는 칸으로 이동한 적은 게임에서 제외
  - 모든 적이 격자판에서 제외되면 게임은 끝

#### [입출력조건]
  - ***N*** v ***M*** v ***D***   격자판 행의 수 N, 열의 수 M, 궁수의 공격 거리 제한 D (3 ≤ N,M ≤ 15, 1 ≤ D ≤ 10)
  - ***map[n][m]*** 격자판의 상태 (0은 빈 칸, 1은 적의 칸)

⇒ 격자판의 상태가 주어졌을 때, 궁수의 공격으로 제거할 수 있는 적의 최대 수 출력

</br></br>
## 2. 문제를 익숙한 용어로 재정의와 추상화
![캐슬 디펜스 합친버전](https://github.com/SSAFY-11th-Seoul15/algo-study/assets/74345771/0edb5dbb-b424-449b-98bd-0f7d1346fa9e)

</br></br>
## 3. 문제를 어떻게 해결할 것인가
### Try 1) 
1. 궁수 3명을 N+1 행에 배치한다.
2. 모든 적들 중 궁수와 D 거리 내에서 가장 가까운 적을 타겟으로 정한다. (다른 궁수가 동시 공격할 수 있으니 아직 제거하지 않는다.)
3. 타겟으로 정한 적을 제거한다.
4. ***모든 적들을 한칸 내린다.***
5. 적이 N+1 행에 도달하면 제거한다. (기존 맵안 조건만 따지면 가능할 것)
6. 2번으로 돌아가 모든 적이 제거 될 때 까지 반복한다.

</br>

### Try 2) 
1. 궁수 3명을 N+1 행에 배치한다.
2. 모든 적들 중 궁수와 D 거리 내에서 가장 가까운 적을 타겟으로 정한다. (다른 궁수가 동시 공격할 수 있으니 아직 제거하지 않는다.)
3. 타겟으로 정한 적을 제거한다.
4. ***궁수를 한칸 올린다.***
5. 적이 궁수가 있는 행에 도달하면 제거한다.
6. 2번으로 돌아가 모든 적이 제거 될 때 까지 반복한다.

</br></br>
## 4. 위 계획을 검증
### Try 1)
``` java
// 1. 궁수 3명을 N+1 행에 배치한다.
comb;

while(combList){
  // 2. 모든 적들 중 궁수와 D 거리 내에서 가장 가까운 적을 타겟으로 정한다. (다른 궁수가 동시 공격할 수 있으니 아직 제거하지 않는다.)
  BFS(){
    // 2-1. 큐에서 거리 별 궁수를 꺼낸다
    // 2-2. 거리 별 궁수 위치가 적의 위치랑 겹친다면 목적지
    exit(){
      // 2-2-1. 타겟으로 정했음을 저장한다.
      return
    }
    // 2-3. 연결되어 있는가 : 왼위오 순으로 탐색
      // 2-4. 갈 수 있는가 : 맵안, 방문하지 않은 곳
        // 2-5. 큐에 넣음
        // 2-6. 체크인
  }

  // 3. 타겟으로 정한 적을 제거한다. : 2-2-1에서 저장한 아이들 삭제
  // 이 부분은 노드에 삭제예정 변수를 추가해두면 될 것

  // 4. ***모든 적들을 한칸 내린다.*** : 전에 저장해둔 모든 적의 행을 +1 연산
    // 5. 적이 N+1 행에 도달하면 제거한다. (기존 맵안 조건만 따지면 가능할 것)

  // 6. 2번으로 돌아가 모든 적이 제거 될 때 까지 반복한다.
}
```

- 1, 궁수 3명을 N+1 행에 배치 : **O(MC3)**
- 2, BFS() : 궁수는 최대 3명이므로, 3명이 모든 맵을 확인했다는 전제로 **O(3*N*M)**
- 3, 타겟으로 정한 적을 제거 : 2번 과정에 포함되었던 저장 로직과 관계가 있으므로 **O(3)**
- 4, 모든 적들을 한칸 내림 : **O(NM)**
- 5, 적이 N+1 행에 도달하면 제거 : 4번 과정에 포함이므로 **O(1)**
- 6, 2번으로 돌아가 모든 적이 제거 될 때 까지 반복 : N번 반복하면 모두 한칸씩 내려가 제외될 것이므로 **O(N)**

=> ***시간복잡도 : O( MC3 × (N × (3×N×M + 3 + N×M)) ) ≈ 6,162,975 (가능)***

</br>

### Try 2)
- ***이후 작성 예정***

</br></br>
## 5. 코드 작성
  
***Try1) 모든 적들을 한칸 내림***

```java

```

</br>

***Try2) 모든 궁수를 한칸 올림***

```java

```
</br></br>
## 6. 결과

![백준 채점표]()

</br></br>
## 7. 회고

