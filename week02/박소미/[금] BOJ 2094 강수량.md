## 1. 문제를 읽고 이해하기
#### [문제] 
  - 공식적인 측정 결과를 바탕으로 이러한 이야기들의 진실 여부를 가려내려 함
  - X년도에는 Y년도 이후 가장 많은 비가 내렸다
  - Y년도, X년도, 그리고 그 사이의 모든 년도들의 강수량에 대한 정보가 알려져 있음
  - Y년도 < Z년도 < X년도를 만족하는 모든 Z들에 대해서, Z년도의 강수량은 X년도보다 적음

#### [입출력조건]
  - ***n*** &nbsp;&nbsp;&nbsp;&nbsp; (1 ≤ n ≤ 50,000)
  - [n]&nbsp;***y*** v ***r*** &nbsp;&nbsp; y년도의 강수량이 r이라는 의미; &nbsp;&nbsp; (0 ≤ |y| ≤ 1,000,000,000), (1 ≤ r ≤ 1,000,000,000)
  - ***m*** &nbsp;&nbsp;&nbsp;&nbsp; (1 ≤ m ≤ 10,000)
  - [m]&nbsp;***Y*** v ***X*** &nbsp;&nbsp; 사람들의 이야기에 대한 정보; &nbsp;&nbsp; (-1,000,000,000 ≤ Y < X ≤ 1,000,000,000)

⇒ m개의 줄에 각 사람들의 이야기에 대한 답 출력 (참:true, 가능할 경우:maybe, 불가능:false)

</br></br>
## 2. 문제를 익숙한 용어로 재정의와 추상화
<img src = "https://github.com/SSAFY-11th-Seoul15/algo-study/assets/74345771/cf6dd13f-a0f8-49f1-a0c0-db64d6e913bb" >

</br></br>
## 3. 문제를 어떻게 해결할 것인가
### Try 1) DP

<img src = "https://github.com/SSAFY-11th-Seoul15/algo-study/assets/74345771/3555e237-c0e5-4da3-b258-1b5d30d2a406" >

</br></br>
***[ 불가능 했던 로직 ]***

<img src = "https://github.com/SSAFY-11th-Seoul15/algo-study/assets/74345771/d62ea0ac-a2b5-4340-a66d-9d41e365f44f" >

</br></br>
***[ 가능 했던 로직 ]***
- Dp[i] = [0 ~ i-1] 에서 arr[i]보다 작은 숫자의 개수
- 누적합과 Dp를 이용한 배열 2개를 추가적으로 선언함
- 누적합 : 일반 배열 arr[]에서 idx 차례의 값인 arr[idx]를 확인하고, 누적합의 인덱스가 arr[idx]인 부분부터 1씩 증가시킴
- 조건 3번에서 같지않고 작아야만 한다고 했으므로, 누적합의 arr[idx]-1 인덱스의 값이 Dp[i]에 들어가게 된다.

<img src = "https://github.com/SSAFY-11th-Seoul15/algo-study/assets/74345771/d317c007-cc20-42ae-b4f4-31da85809dcc" >

</br></br>

</br></br>
## 4. 위 계획을 검증
### Try 1) DP

- 1, 일반 배열을 통해 누적합, Dp 배열을 만든다 : ***O(n^2)***
- 2, Dp 배열을 통해서 각 사람들의 이야기에 대한 답을 출력한다 :  ***O(m)***

=> ***시간복잡도 : O( n^2 X m ) ≈ 25,000,000,000,000 (불가능)***

</br>

</br></br>
## 5. 코드 작성
  
***Try1)***

```java

```

</br>
</br></br>
## 6. 결과

![백준 채점표]()

</br></br>
## 7. 회고

